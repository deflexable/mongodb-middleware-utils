import{MongoClient as t}from"mongodb";import{BSONRegExp as e,Long as n,Double as r,Int32 as i,Decimal128 as a,Code as o,ObjectId as s,Binary as l,MaxKey as c,MinKey as f,UUID as u,Timestamp as d,BSONSymbol as p}from"mongodb/lib/bson";import{Worker as m}from"worker_threads";import{fileURLToPath as y}from"url";import{dirname as h}from"path";import{S as g,g as w,t as $}from"./worker-Cfns5Kwr.js";const b="undefined"!=typeof __dirname?__dirname:h(y(import.meta.url)),O="__fta_",x="__rdz";class _ extends t{constructor({map:t,url:e,tokenizer:n,options:r}){super(e,r),this.interceptMap={map:t,tokenizer:n},v(super.db.bind(this),this.interceptMap)}get db(){return M(super.db.bind(this),this.interceptMap)}__intercepted=!0}const A=t=>e=>{if(e.__intercepted)throw"this MongoClient instance was previously intercepted";v(e.db.bind(e),t);const n=e.db.bind(e);e.db=M(n,t),e.__intercepted=!0},v=(t,e)=>{const{map:n,tokenizer:r,indexNotice:i}=e;if(void 0!==r&&"function"!=typeof r)throw`expected a function for field:"tokenizer" but got ${r}`;if(void 0!==i&&!["warn","error","off"].some((t=>i===t)))throw`expected either a function or any of 'warn', 'error', 'off' for field:"indexNotice" but got ${i}`;Object.entries(n).forEach((([e,n])=>{Object.entries(n).forEach((([n,i])=>{const a=`dbName(${e}), collectionName(${n})`,{fulltext:o,random:s,safeOverhead:l,overhead:c}=i||{};if(o)if(Array.isArray(o)){if(o.filter((t=>"string"!=typeof t||t.includes(".")||!t.trim())).length)throw`invalid interception value in ${a}, fulltext array must contain a non empty string without "." value but got ${JSON.stringify(o)}`;if(!o.length)throw`invalid interception value in ${a}, fulltext array must not be empty`;if(o.filter(((t,e,n)=>n.indexOf(t)===e)).length!==o.length)throw`invalid interception value in ${a}, fulltext array must not contain duplicate value but got ${o}`}else{if("string"!=typeof o||o.includes("."))throw`invalid interception value in ${a}, fulltext must either be a string without "." or array but got ${o}`;if(!o.trim())throw`invalid interception value in ${a}, fulltext must not be empty`}if(void 0!==s&&"boolean"!=typeof s)throw`invalid interception value in ${a}, random should be a boolean value but got ${i}`;if(l&&!c)throw'"safeOverhead" should only be true when "overhead" is true';if(c&&!g.listeningFulltext[a]&&(o||s)){g.listeningFulltext[a]=!0;const i=t(e).collection(n),c=i.watch(),f=o?Array.isArray(o)?o:[o]:[];console.log("listening overhead:",n),c.on("change",(async({operationType:t,fullDocument:e,updateDescription:n,documentKey:a})=>{if("delete"===t)return;const{_id:c}=a,u=e||await i.findOne({_id:c});if(!u)return;const d=o?"insert"===t?f.filter((t=>!u[`${O}${t}`])):Object.keys(n?.updatedFields||{}).filter((t=>f.includes(t))):[];if(d.length||s&&!u[x])if(console.log("overhead working"),l){const t=15728640-JSON.stringify({...u,...Object.fromEntries(d.map((t=>[t])))}).length;if(t>0){const e=await Promise.all(d.map((async t=>{const e=u[t],n="string"==typeof e&&await(r?.(e));return[t,await D(r?n:e)]}))),n=e.map((([t])=>[t,new Set([])]));let a,o=0;for(let r=0;r<e.length&&!a;r++)for(let i=0;i<e[r][1].length;i++){const s=e[r][1][i];if((a=o+=s.length+4)>=t)break;n[r][1].add(s)}i.updateOne({_id:c},{$set:{...Object.fromEntries(n.map((([t,e])=>[`${O}${t}`,[...e]])).filter((t=>t[1].length))),...u[x]?{}:{[x]:Math.random()}}})}else u[x]||i.updateOne({_id:c},{$set:{[x]:Math.random()}})}else{const t=await Promise.all(d.map((async t=>{const e=u[t],n="string"==typeof e&&await(r?.(e));return[`${O}${t}`,await D(r?n:e)]})));i.updateOne({_id:c},{$set:{...Object.fromEntries(t),...u[x]?{}:{[x]:Math.random()}}})}}))}}))}))},M=(t,e)=>function(){const{map:n,tokenizer:r,indexNotice:i}=e,a=t(...arguments),[o]=[...arguments];let s=function(){const t=[...arguments],e=a.collection(...t),s={},l=t[0];return Object.entries(n).forEach((([t,n])=>{Object.entries(n).forEach((([n,a])=>{const c={...a,tokenizer:r};if(o===t&&l===n&&(c?.fulltext||c?.random)){const{fulltext:t,random:n}=c,r=e=>{if(e?.$text?.$search&&t){const n=e.$text.$field||t,r=Array.isArray(n)?n:[n];if(r.filter(((t,e,n)=>n.indexOf(t)===e)).length!==r.length)throw"$field must not contain duplicate values";delete(e={...e,$or:[...e?.$or||[],...r.map((t=>({[`${O}${t}`]:{$in:[j(e?.$text?.$search)]}})))]}).$text}return e},a=t=>{const e=(Array.isArray(t)?t:[t]).map((t=>{if(!t)return t;const e={...t};return Object.keys(t).forEach((t=>{(t.startsWith(O)||t===x)&&delete e[t]})),e}));return Array.isArray(t)?e:e[0]},o=async e=>(S(e)&&((e={...e}).$set&&(e.$set=await k(e.$set,c)),e.$setOnInsert&&(e.$setOnInsert=await k(e.$setOnInsert,c)),e.$unset&&(Array.isArray(t)?t:[t]).forEach((t=>{e.$unset[t]&&(e.$unset[`${O}${t}`]=!0)}))),e);s.insertOne=async function(){return await e.insertOne(await k([...arguments][0],c),[...arguments][1])},s.insertMany=async function(){return await e.insertMany(await Promise.all([...arguments][0].map((t=>k(t,c)))),[...arguments][1])},["updateOne","updateMany"].forEach((t=>{s[t]=async function(){const n=[...arguments],a=r(n[0]);return await P(e.find(a).limit(1),i),await e[t](a,await o(n[1]),n[2])}})),s.replaceOne=async function(){const t=[...arguments],n=r(t[0]);return await P(e.find(n).limit(1),i),await e.replaceOne(n,await k(t[1],c),t[2])},s.bulkWrite=async function(){let[t,...n]=[...arguments];return await e.bulkWrite(await Promise.all(t.map((async t=>{const n={};return await Promise.all(Object.entries(t).map((async([t,a])=>{"insertOne"!==t&&await P(e.find(a.filter).limit(1),i),n[t]={...a,...a.filter?{filter:r(a.filter)}:{},...a.arrayFilters?{}:{arrayFilters:a.arrayFilters.map(r)},...a.document?{document:await k(a.document,c)}:{},...a.replacement?{replacement:await k(a.replacement,c)}:{},...a.update?{update:await o(a.update)}:{}}}))),n}))),...n)},s.find=function(){let[t,...n]=[...arguments];const o=r(t),s=e.find(o,...n),l=s.toArray.bind(s),c=s.limit.bind(s);return s.toArray=async()=>(await P(c(1),i),a(await l())),s},s.findOne=async function(){let[t,...n]=[...arguments];const o=r(t);await P(e.find(o).limit(1),i);const s=await e.findOne(o,...n);return a(s)},s.watch=function(){const[t,...n]=[...arguments],i=e.watch(Array.isArray(t)?t.map(r):r(t),...n),o={},s={};return["on","once","prependListener","addListener","prependOnceListener"].forEach((t=>{o[t]=(e,n)=>{if("change"===e){const e=`${Math.random()}`;return s[e]=t=>{const e=t;e.fullDocument&&(e.fullDocument=a(e.fullDocument)),e.fullDocumentBeforeChange&&(e.fullDocumentBeforeChange=a(e.fullDocumentBeforeChange)),e.updateDescription?.updatedFields&&(e.updateDescription.updatedFields=a(e.updateDescription.updatedFields)),n?.(e)},n.prototype||(n.prototype={}),n.prototype.__cloneMongodbListener||(n.prototype.__cloneMongodbListener=[]),n.prototype.__cloneMongodbListener.push(e),i[t]("change",s[e])}return i[t](e,n)}})),["off","removeListener"].forEach((t=>{o[t]=(e,n)=>{if("change"===e){const r=n.prototype?.__cloneMongodbListener;r&&(r.forEach((n=>{i[t](e,s[n]),s[n]&&delete s[n]})),delete n.prototype.__cloneMongodbListener)}else i[t](e,t)}})),new Proxy({},{get:(t,e)=>o[e]?o[e]:"function"==typeof i[e]?i[e].bind(i):i[e],set:(t,e,n)=>(o[e]?o[e]=n:i[e]=n,!0)})},s.aggregate=function(){const[t,o]=[...arguments],[s,l]=t,c=s?.$sample?.size,f=r(l?.$match),u=Number.isInteger(c)&&c>0&&n,d=e.aggregate(t.map((t=>t?.$match?{...t,$match:r(t.$match)}:t)),o),p=d.toArray.bind(d);d.toArray=async()=>a(await p());let m=async()=>{const[[t,n]]=await Promise.all([Promise.all(["asc","desc"].map((t=>e.find({...f},o).sort(x,t).limit(1).toArray()))),Promise.all(["asc","desc"].map((t=>P(e.find(f).sort(x,t).limit(1),i))))]),[r,s]=[t[0]?.[x],n[0]?.[x]].map((t=>t&&1*t));if(isNaN(r)||isNaN(s))return[];if(r===s)return a(t);{const t=c+0,n=(s-r)/t,i=[];let l=r;Array(t).fill().forEach((()=>{i.push(E(l+=n,l))}));const u=await Promise.all(i.map((t=>e.find({...f,[x]:{$gte:t}},o).sort(x,"asc").limit(3).toArray()))),d=N(u.flat().filter(((t,e,n)=>n.findIndex((e=>L.equal(e._id,t._id)))===e)));if(d.length>=c)return a(d.slice(0,c));{const t=await Promise.all(["asc","desc"].map((t=>e.find({...f},o).sort(x,t).limit(Math.ceil(c/2)).toArray()))),n=[...d,...N(t.flat().filter(((t,e,n)=>n.findIndex((e=>L.equal(e._id,t._id)))===e)))].filter(((t,e,n)=>n.findIndex((e=>L.equal(e._id,t._id)))===e));return a(n.slice(0,c))}}};return new Proxy({},{get:(t,e)=>"toArray"===e&&u?m:"function"==typeof d[e]?d[e].bind(d):d[e],set:(t,e,n)=>("toArray"===e&&u?m=n:d[e]=n,!0)})}}}))})),new Proxy({},{get:(t,n)=>s[n]?s[n]:"function"==typeof e[n]?e[n].bind(e):e[n],set:(t,n,r)=>(s[n]?s[n]=r:e[n]=r,!0)})};return new Proxy({},{get:(t,e)=>"collection"===e?s:"function"==typeof a[e]?a[e].bind(a):a[e],set:(t,e,n)=>("collection"===e?s=n:a[e]=n,!0)})},P=async(t,e)=>{if("off"===e||!e)return;const n=await t.explain("queryPlanner"),{stage:r,indexName:i,inputStage:a}={...n?.queryPlanner?.winningPlan?.inputStage},{stage:o,indexName:s}={...a};if(!("IXSCAN"===r&&i||"IXSCAN"===o&&s)){if("function"==typeof e)return void e(n?.command);const t="cannot perform an index scan for mongodb query with command:";if("error"===e)throw`${t} ${JSON.stringify(n?.command)}`;console.warn(t,n?.command)}},N=t=>{const e=[...t];let n,r=e.length;for(;0!=r;)n=Math.floor(Math.random()*r),r--,[e[r],e[n]]=[e[n],e[r]];return e},E=(t=70,e=0)=>(t-e)*Math.random()+e,j=t=>$(t.trim()),k=async(t,{fulltext:e,random:n,overhead:r,tokenizer:i})=>{if(r)return t;if(!S(t))return t;const a={...t};return e&&(e=Array.isArray(e)?e:[e],await Promise.all(e.map((async e=>{const n=t[e];if("string"==typeof n&&n.trim()&&!t[`${O}${e}`]){const t="string"==typeof n&&await(i?.(n));a[`${O}${e}`]=await D(i?t:n)}})))),n&&!t[x]&&(a[x]=Math.random()),a},S=t=>null!==t&&"object"==typeof t&&!Array.isArray(t),D=async t=>{if(!t?.trim?.())return[];const e=I(t),n=e.length>1?await Promise.all(e.map((t=>z(`${b}/worker.js`,{text:t})))):e.map((t=>({indexes:w(t)})));return[...new Set(n.map((t=>t.indexes)).flat())]},z=(t,e)=>new Promise((n=>{const r=new m(t);r.on("message",(t=>{n(t),r.terminate()})),r.postMessage(e)})),F=2e4,I=(t="")=>{t=t.split(" ");let e=[[]],n=0,r=0;for(let i=0;i<t.length;i++){const a=t[i];r+=a.length,++n<=2700&&r<F||!e[e.length-1].length?e[e.length-1].push(a):(e.push([a]),r=a.length,n=1)}const i=[];return e.forEach((t=>{t.length&&(t[0].length>F?Array(Math.ceil(t[0].length/F)).fill().forEach(((e,n)=>{i.push(t[0].substring(n*F,(n+1)*F))})):i.push(t.join(" ")))})),i},L={equal:(t,e,n)=>(t=J(t),e=J(e),C(e)||C(t)?q(t,e)&&JSON.stringify(t)===JSON.stringify(e):e instanceof RegExp?q(t,e)?t.source===e.source&&t.flags===e.flags:n&&"string"==typeof t&&e.test(t):JSON.stringify(t)===JSON.stringify(e))},q=(t,e)=>{try{return t.constructor===e.constructor&&Object.getPrototypeOf(t)===Object.getPrototypeOf(e)}catch(t){return!1}},J=t=>t instanceof e?new RegExp(t.pattern,t.options):[n,r,i,a].some((e=>t instanceof e))?1*t:t,C=t=>[o,s,l,c,f,u,d,p].some((e=>t instanceof e));export{O as FULLTEXT_ARRAY_PREFIX,_ as MongoClientHack,x as RANDOMIZER_FIELD,D as getFulltextArray,A as proxyClient};
