import{MongoClient as t}from"mongodb";import{BSONRegExp as e,Long as n,Double as r,Int32 as i,Decimal128 as a,Code as o,ObjectId as s,Binary as l,MaxKey as c,MinKey as f,UUID as u,Timestamp as d,BSONSymbol as p}from"mongodb/lib/bson";import{Worker as m}from"worker_threads";import{fileURLToPath as y}from"url";import{dirname as g}from"path";import{S as h,g as w,t as $}from"./worker-Cfns5Kwr.js";const b="undefined"!=typeof __dirname?__dirname:g(y(import.meta.url)),O="__fta_",x="__rdz";class _ extends t{constructor({map:t,url:e,tokenizer:n,indexNotice:r,options:i}){super(e,i),this.interceptMap={map:t,tokenizer:n,indexNotice:r},v(super.db.bind(this),this.interceptMap)}get db(){return M(super.db.bind(this),this.interceptMap)}__intercepted=!0}const A=t=>e=>{if(e.__intercepted)throw"this MongoClient instance was previously intercepted";v(e.db.bind(e),t);const n=e.db.bind(e);e.db=M(n,t),e.interceptMap=t,e.__intercepted=!0},v=(t,e)=>{const{map:n,tokenizer:r,indexNotice:i}=e;if(void 0!==r&&"function"!=typeof r)throw`expected a function for field:"tokenizer" but got ${r}`;if(void 0!==i&&"function"!=typeof i&&!["warn","error","off"].some((t=>i===t)))throw`expected either a function or any of 'warn', 'error', 'off' for field:"indexNotice" but got ${i}`;Object.entries(n||{}).forEach((([e,n])=>{Object.entries(n).forEach((([n,i])=>{const a=`dbName(${e}), collectionName(${n})`,{fulltext:o,random:s,safeOverhead:l,overhead:c}=i||{};if(o)if(Array.isArray(o)){if(o.filter((t=>"string"!=typeof t||t.includes(".")||!t.trim())).length)throw`invalid interception value in ${a}, fulltext array must contain a non empty string without "." value but got ${JSON.stringify(o)}`;if(!o.length)throw`invalid interception value in ${a}, fulltext array must not be empty`;if(o.filter(((t,e,n)=>n.indexOf(t)===e)).length!==o.length)throw`invalid interception value in ${a}, fulltext array must not contain duplicate value but got ${o}`}else{if("string"!=typeof o||o.includes("."))throw`invalid interception value in ${a}, fulltext must either be a string without "." or array but got ${o}`;if(!o.trim())throw`invalid interception value in ${a}, fulltext must not be empty`}if(void 0!==s&&"boolean"!=typeof s)throw`invalid interception value in ${a}, random should be a boolean value but got ${i}`;if(l&&!c)throw'"safeOverhead" should only be true when "overhead" is true';if(c&&!h.listeningFulltext[a]&&(o||s)){h.listeningFulltext[a]=!0;const i=t(e).collection(n),c=i.watch(),f=o?Array.isArray(o)?o:[o]:[];console.log("listening overhead:",n),c.on("change",(async({operationType:t,fullDocument:e,updateDescription:n,documentKey:a})=>{if("delete"===t)return;const{_id:c}=a,u=e||await i.findOne({_id:c});if(!u)return;const d=o?"insert"===t?f.filter((t=>!u[`${O}${t}`])):Object.keys(n?.updatedFields||{}).filter((t=>f.includes(t))):[];if(d.length||s&&!u[x])if(console.log("overhead working"),l){const t=15728640-JSON.stringify({...u,...Object.fromEntries(d.map((t=>[t])))}).length;if(t>0){const e=await Promise.all(d.map((async t=>{const e=u[t],n="string"==typeof e&&await(r?.(e));return[t,await I(r?n:e)]}))),n=e.map((([t])=>[t,new Set([])]));let a,o=0;for(let r=0;r<e.length&&!a;r++)for(let i=0;i<e[r][1].length;i++){const s=e[r][1][i];if((a=o+=s.length+4)>=t)break;n[r][1].add(s)}i.updateOne({_id:c},{$set:{...Object.fromEntries(n.map((([t,e])=>[`${O}${t}`,[...e]])).filter((t=>t[1].length))),...u[x]?{}:{[x]:Math.random()}}})}else u[x]||i.updateOne({_id:c},{$set:{[x]:Math.random()}})}else{const t=await Promise.all(d.map((async t=>{const e=u[t],n="string"==typeof e&&await(r?.(e));return[`${O}${t}`,await I(r?n:e)]})));i.updateOne({_id:c},{$set:{...Object.fromEntries(t),...u[x]?{}:{[x]:Math.random()}}})}}))}}))}))},M=(t,e)=>function(){const{map:n,tokenizer:r,indexNotice:i}=e,a="off"!==i&&i,o=t(...arguments),[s]=[...arguments];let l=function(){const t=[...arguments],e=o.collection(...t),l={},c=t[0];return Object.entries(n||{}).forEach((([t,n])=>{Object.entries(n).forEach((([n,o])=>{const f={...o,tokenizer:r};if(s===t&&c===n&&(f?.fulltext||f?.random)){const{fulltext:t,random:n}=f,r=e=>{if(e?.$text?.$search&&t){const n=e.$text.$field||t,r=Array.isArray(n)?n:[n];if(r.filter(((t,e,n)=>n.indexOf(t)===e)).length!==r.length)throw"$field must not contain duplicate values";delete(e={...e,$or:[...e?.$or||[],...r.map((t=>({[`${O}${t}`]:{$in:[j(e?.$text?.$search)]}})))]}).$text}return e},o=t=>{const e=(Array.isArray(t)?t:[t]).map((t=>{if(!t)return t;const e={...t};return Object.keys(t).forEach((t=>{(t.startsWith(O)||t===x)&&delete e[t]})),e}));return Array.isArray(t)?e:e[0]},s=async e=>(S(e)&&((e={...e}).$set&&(e.$set=await k(e.$set,f)),e.$setOnInsert&&(e.$setOnInsert=await k(e.$setOnInsert,f)),e.$unset&&(Array.isArray(t)?t:[t]).forEach((t=>{e.$unset[t]&&(e.$unset[`${O}${t}`]=!0)}))),e);l.insertOne=async function(){return await e.insertOne(await k([...arguments][0],f),[...arguments][1])},l.insertMany=async function(){return await e.insertMany(await Promise.all([...arguments][0].map((t=>k(t,f)))),[...arguments][1])},["updateOne","updateMany"].forEach((t=>{l[t]=async function(){const n=[...arguments],o=r(n[0]);return a&&await N(e.find(o).limit(1),i),await e[t](o,await s(n[1]),n[2])}})),l.replaceOne=async function(){const t=[...arguments],n=r(t[0]);return a&&await N(e.find(n).limit(1),i),await e.replaceOne(n,await k(t[1],f),t[2])},l.bulkWrite=async function(){let[t,...n]=[...arguments];return await e.bulkWrite(await Promise.all(t.map((async t=>{const n={};return await Promise.all(Object.entries(t).map((async([t,o])=>{"insertOne"!==t&&a&&await N(e.find(o.filter).limit(1),i),n[t]={...o,...o.filter?{filter:r(o.filter)}:{},...o.arrayFilters?{}:{arrayFilters:o.arrayFilters.map(r)},...o.document?{document:await k(o.document,f)}:{},...o.replacement?{replacement:await k(o.replacement,f)}:{},...o.update?{update:await s(o.update)}:{}}}))),n}))),...n)},l.find=function(){const[t,...n]=[...arguments],s=e.find(r(t),...n),l=s.toArray.bind(s);return s.toArray=async()=>(a&&await N(s.clone().limit(1),i),o(await l())),s},l.findOne=async function(){let[t,...n]=[...arguments];const s=r(t);a&&await N(e.find(s).limit(1),i);const l=await e.findOne(s,...n);return o(l)},l.watch=function(){const[t,...n]=[...arguments],i=e.watch(Array.isArray(t)?t.map(r):r(t),...n),a={},s={};return["on","once","prependListener","addListener","prependOnceListener"].forEach((t=>{a[t]=(e,n)=>{if("change"===e){const e=`${Math.random()}`;return s[e]=t=>{const e=t;e.fullDocument&&(e.fullDocument=o(e.fullDocument)),e.fullDocumentBeforeChange&&(e.fullDocumentBeforeChange=o(e.fullDocumentBeforeChange)),e.updateDescription?.updatedFields&&(e.updateDescription.updatedFields=o(e.updateDescription.updatedFields)),n?.(e)},n.prototype||(n.prototype={}),n.prototype.__cloneMongodbListener||(n.prototype.__cloneMongodbListener=[]),n.prototype.__cloneMongodbListener.push(e),i[t]("change",s[e])}return i[t](e,n)}})),["off","removeListener"].forEach((t=>{a[t]=(e,n)=>{if("change"===e){const r=n.prototype?.__cloneMongodbListener;r&&(r.forEach((n=>{i[t](e,s[n]),s[n]&&delete s[n]})),delete n.prototype.__cloneMongodbListener)}else i[t](e,t)}})),new Proxy({},{get:(t,e)=>a[e]?a[e]:"function"==typeof i[e]?i[e].bind(i):i[e],set:(t,e,n)=>(a[e]?a[e]=n:i[e]=n,!0)})},l.aggregate=function(){const[t,s]=[...arguments],[l,c]=t,f=l?.$sample?.size,u=r(c?.$match),d=Number.isInteger(f)&&f>0&&n,p=e.aggregate(t.map((t=>t?.$match?{...t,$match:r(t.$match)}:t)),s),m=p.toArray.bind(p);p.toArray=async()=>o(await m());let y=async()=>{const[[t,n]]=await Promise.all([Promise.all(["asc","desc"].map((t=>e.find({...u},s).sort(x,t).limit(1).toArray()))),Promise.all(["asc","desc"].map((t=>a?N(e.find(u).sort(x,t).limit(1),i):Promise.resolve())))]),[r,l]=[t[0]?.[x],n[0]?.[x]].map((t=>t&&1*t));if(isNaN(r)||isNaN(l))return[];if(r===l)return o(t);{const t=f+0,n=(l-r)/t,i=[];let a=r;Array(t).fill().forEach((()=>{i.push(P(a+=n,a))}));const c=await Promise.all(i.map((t=>e.find({...u,[x]:{$gte:t}},s).sort(x,"asc").limit(3).toArray()))),d=E(c.flat().filter(((t,e,n)=>n.findIndex((e=>F.equal(e._id,t._id)))===e)));if(d.length>=f)return o(d.slice(0,f));{const t=await Promise.all(["asc","desc"].map((t=>e.find({...u},s).sort(x,t).limit(Math.ceil(f/2)).toArray()))),n=[...d,...E(t.flat().filter(((t,e,n)=>n.findIndex((e=>F.equal(e._id,t._id)))===e)))].filter(((t,e,n)=>n.findIndex((e=>F.equal(e._id,t._id)))===e));return o(n.slice(0,f))}}};return new Proxy({},{get:(t,e)=>"toArray"===e&&d?y:"function"==typeof p[e]?p[e].bind(p):p[e],set:(t,e,n)=>("toArray"===e&&d?y=n:p[e]=n,!0)})}}}))})),new Proxy({},{get:(t,n)=>l[n]?l[n]:"function"==typeof e[n]?e[n].bind(e):e[n],set:(t,n,r)=>(l[n]?l[n]=r:e[n]=r,!0)})};return new Proxy({},{get:(t,e)=>"collection"===e?l:"function"==typeof o[e]?o[e].bind(o):o[e],set:(t,e,n)=>("collection"===e?l=n:o[e]=n,!0)})},N=async(t,e)=>{if("off"===e||!e)return;const n=await t.explain("queryPlanner"),{winningPlan:r,parsedQuery:i}=n?.queryPlanner||{},a=!Object.keys(i||{}).length,o=t=>["GEO_NEAR_2DSPHERE"].includes(t?.stage)&&!!t.indexName,s=t=>"TEXT_MATCH"===t?.stage&&!!t.indexName;if("IDHACK"===r?.stage)return;if(o(r)||"LIMIT"===r?.stage&&o(r.inputStage))return;if(s(r)||"LIMIT"===r?.stage&&s(r.inputStage))return;const l=t=>"FETCH"===t?.stage&&!t.filter&&(t=t.inputStage)&&"IXSCAN"===t.stage&&!!t.indexName;if(l(r))return;if("LIMIT"===r?.stage&&!r.filter&&l(r.inputStage))return;if(a){const t=t=>"COLLSCAN"===t?.stage&&t.direction&&2===Object.keys(t).length;if(t(r)||"LIMIT"===r?.stage&&!r.filter&&t(r.inputStage))return}if("function"==typeof e)return void e(n?.command);const c="cannot perform an index scan for mongodb query with command:";if("error"===e)throw`${c} ${JSON.stringify(n?.command)}`;console.warn(c,n?.command)},E=t=>{const e=[...t];let n,r=e.length;for(;0!=r;)n=Math.floor(Math.random()*r),r--,[e[r],e[n]]=[e[n],e[r]];return e},P=(t=70,e=0)=>(t-e)*Math.random()+e,j=t=>$(t.trim()),k=async(t,{fulltext:e,random:n,overhead:r,tokenizer:i})=>{if(r)return t;if(!S(t))return t;const a={...t};return e&&(e=Array.isArray(e)?e:[e],await Promise.all(e.map((async e=>{const n=t[e];if("string"==typeof n&&n.trim()&&!t[`${O}${e}`]){const t="string"==typeof n&&await(i?.(n));a[`${O}${e}`]=await I(i?t:n)}})))),n&&!t[x]&&(a[x]=Math.random()),a},S=t=>null!==t&&"object"==typeof t&&!Array.isArray(t),I=async t=>{if(!t?.trim?.())return[];const e=C(t),n=e.length>1?await Promise.all(e.map((t=>L(`${b}/worker.js`,{text:t})))):e.map((t=>({indexes:w(t)})));return[...new Set(n.map((t=>t.indexes)).flat())]},L=(t,e)=>new Promise((n=>{const r=new m(t);r.on("message",(t=>{n(t),r.terminate()})),r.postMessage(e)})),D=2e4,C=(t="")=>{t=t.split(" ");let e=[[]],n=0,r=0;for(let i=0;i<t.length;i++){const a=t[i];r+=a.length,++n<=2700&&r<D||!e[e.length-1].length?e[e.length-1].push(a):(e.push([a]),r=a.length,n=1)}const i=[];return e.forEach((t=>{t.length&&(t[0].length>D?Array(Math.ceil(t[0].length/D)).fill().forEach(((e,n)=>{i.push(t[0].substring(n*D,(n+1)*D))})):i.push(t.join(" ")))})),i},F={equal:(t,e,n)=>(t=T(t),e=T(e),q(e)||q(t)?z(t,e)&&JSON.stringify(t)===JSON.stringify(e):e instanceof RegExp?z(t,e)?t.source===e.source&&t.flags===e.flags:n&&"string"==typeof t&&e.test(t):JSON.stringify(t)===JSON.stringify(e))},z=(t,e)=>{try{return t.constructor===e.constructor&&Object.getPrototypeOf(t)===Object.getPrototypeOf(e)}catch(t){return!1}},T=t=>t instanceof e?new RegExp(t.pattern,t.options):[n,r,i,a].some((e=>t instanceof e))?1*t:t,q=t=>[o,s,l,c,f,u,d,p].some((e=>t instanceof e));export{O as FULLTEXT_ARRAY_PREFIX,_ as MongoClientHack,x as RANDOMIZER_FIELD,I as getFulltextArray,A as proxyClient};
