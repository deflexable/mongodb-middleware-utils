"use strict";var e=require("mongodb"),t=require("worker_threads"),n=require("url"),r=require("path"),i=require("./worker-rtLqju9E.js"),a="undefined"!=typeof document?document.currentScript:null;const o="undefined"!=typeof __dirname?__dirname:r.dirname(n.fileURLToPath("undefined"==typeof document?require("url").pathToFileURL(__filename).href:a&&a.src||new URL("index.js",document.baseURI).href)),s="__fta_",l="__rdz";class c extends e.MongoClient{constructor({map:e,url:t,options:n}){super(t,n),this.interceptMap=e,u(super.db.bind(this),this.interceptMap)}get db(){return f(super.db.bind(this),this.interceptMap)}__intercepted=!0}const u=(e,t)=>{Object.entries(t).forEach((([t,n])=>{Object.entries(n).forEach((([n,r])=>{const a=`dbName(${t}), collectionName(${n})`,{fulltext:o,random:c,safeOverhead:u,overhead:f}=r||{};if(o)if(Array.isArray(o)){if(o.filter((e=>"string"!=typeof e||e.includes(".")||!e.trim())).length)throw`invalid interception value in ${a}, fulltext array must contain a non empty string without "." value but got ${JSON.stringify(o)}`;if(!o.length)throw`invalid interception value in ${a}, fulltext array must not be empty`;if(o.filter(((e,t,n)=>n.indexOf(e)===t)).length!==o.length)throw`invalid interception value in ${a}, fulltext array must not contain duplicate value but got ${o}`}else{if("string"!=typeof o||o.includes("."))throw`invalid interception value in ${a}, fulltext must either be a string without "." or array but got ${o}`;if(!o.trim())throw`invalid interception value in ${a}, fulltext must not be empty`}if(void 0!==c&&"boolean"!=typeof c)throw`invalid interception value in ${a}, random should be a boolean value but got ${r}`;if(u&&!f)throw'"safeOverhead" should only be true when "overhead" is true';if(f&&!i.Scope.listeningFulltext[a]&&(o||c)){i.Scope.listeningFulltext[a]=!0;const r=e(t).collection(n),f=r.watch(),d=o?Array.isArray(o)?o:[o]:[];console.log("listening overhead:",n),f.on("change",(async({operationType:e,fullDocument:t,updateDescription:n,documentKey:i})=>{if("delete"===e)return;const{_id:a}=i,f=t||await r.findOne({_id:a});if(!f)return;const p=o?"insert"===e?d.filter((e=>!f[`${s}${e}`])):Object.keys(n?.updatedFields||{}).filter((e=>d.includes(e))):[];if(p.length||c&&!f[l])if(console.log("overhead working"),u){const e=15728640-JSON.stringify({...f,...Object.fromEntries(p.map((e=>[e])))}).length;if(e>0){const t=await Promise.all(p.map((async e=>[e,await g(f[e])]))),n=t.map((([e])=>[e,new Set([])]));let i,o=0;for(let r=0;r<t.length&&!i;r++)for(let a=0;a<t[r][1].length;a++){const s=t[r][1][a];if(i=(o+=s.length+4)>=e)break;n[r][1].add(s)}r.updateOne({_id:a},{$set:{...Object.fromEntries(n.map((([e,t])=>[`${s}${e}`,[...t]])).filter((e=>e[1].length))),...f[l]?{}:{[l]:Math.random()}}})}else f[l]||r.updateOne({_id:a},{$set:{[l]:Math.random()}})}else{const e=await Promise.all(p.map((async e=>[`${s}${e}`,await g(f[e])])));r.updateOne({_id:a},{$set:{...Object.fromEntries(e),...f[l]?{}:{[l]:Math.random()}}})}}))}}))}))},f=(e,t)=>function(){const n=e(...arguments),[r]=[...arguments];let i=function(){const e=[...arguments],i=n.collection(...e),a={},o=e[0];return Object.entries(t).forEach((([e,t])=>{Object.entries(t).forEach((([t,n])=>{if(r===e&&o===t&&(n?.fulltext||n?.random)){const{fulltext:e,random:t}=n,r=t=>{if(t?.$text?.$search&&e){const n=t.$text.$field||e,r=Array.isArray(n)?n:[n];if(r.filter(((e,t,n)=>n.indexOf(e)===t)).length!==r.length)throw"$field must not contain duplicate values";delete(t={...t,$or:[...t?.$or||[],...r.map((e=>({[`${s}${e}`]:{$in:[h(t?.$text?.$search)]}})))]}).$text}return t},o=e=>{let t=e;if(Buffer.isBuffer(t)&&(t=JSON.parse(Buffer.from(t).toString("utf-8"))),!t)return Buffer.isBuffer(e)?e:t;let n=(Array.isArray(t)?t:[t]).map((e=>{const t={...e};return Object.keys(e).forEach((e=>{(e.startsWith(s)||e===l)&&delete t[e]})),t}));return n=Array.isArray(t)?n:n[0],Buffer.isBuffer(e)?Buffer.from(JSON.stringify(n),"utf8"):n},c=async t=>(y(t)&&((t={...t}).$set&&(t.$set=await m(t.$set,n)),t.$setOnInsert&&(t.$setOnInsert=await m(t.$setOnInsert,n)),t.$unset&&(Array.isArray(e)?e:[e]).forEach((e=>{t.$unset[e]&&(t.$unset[`${s}${e}`]=!0)}))),t);a.insertOne=async function(){return await i.insertOne(await m([...arguments][0],n),[...arguments][1])},a.insertMany=async function(){return await i.insertMany(await Promise.all([...arguments][0].map((e=>m(e,n)))),[...arguments][1])},["updateOne","updateMany"].forEach((e=>{a[e]=async function(){const t=[...arguments];return await i[e](r(t[0]),await c(t[1]),t[2])}})),a.replaceOne=async function(){return await i.replaceOne(r([...arguments][0]),await m([...arguments][1],n),[...arguments][2])},a.bulkWrite=async function(){let[e,...t]=[...arguments];return await i.bulkWrite(await Promise.all(e.map((async e=>{const t={};return await Promise.all(Object.entries(e).map((async([e,i])=>{t[e]={...i,...i.filter?{filter:r(i.filter)}:{},...i.arrayFilters?{}:{arrayFilters:i.arrayFilters.map(r)},...i.document?{document:await m(i.document,n)}:{},...i.replacement?{replacement:await m(i.replacement,n)}:{},...i.update?{update:await c(i.update)}:{}}}))),t}))),...t)},a.find=function(){let[e,...t]=[...arguments];const n=i.find(r(e),...t),a=n.toArray.bind(n);return n.toArray=async()=>o(await a()),n},a.findOne=async function(){let[e,...t]=[...arguments];const n=await i.findOne(r(e),...t);return o(n)},a.watch=function(){const[e,...t]=[...arguments],n=i.watch(Array.isArray(e)?e.map(r):r(e),...t),a={};let s=0,l={};return["on","once","prependListener","addListener","prependOnceListener"].forEach((e=>{a[e]=(t,r)=>{if("change"===t){const t=""+ ++s;return l[t]=e=>{const t=Buffer.isBuffer(e)?JSON.parse(Buffer.from(e).toString("utf-8")):e;t.fullDocument&&(t.fullDocument=o(t.fullDocument)),t.fullDocumentBeforeChange&&(t.fullDocumentBeforeChange=o(t.fullDocumentBeforeChange)),t.updateDescription?.updatedFields&&(t.updateDescription.updatedFields=o(t.updateDescription.updatedFields)),r?.(Buffer.isBuffer(e)?Buffer.from(JSON.stringify(t),"utf8"):t)},r.prototype||(r.prototype={}),r.prototype.__cloneMongodbListener||(r.prototype.__cloneMongodbListener=[]),r.prototype.__cloneMongodbListener.push(t),n[e]("change",l[t])}return n[e](t,r)}})),["off","removeListener"].forEach((e=>{a[e]=(t,r)=>{if("change"===t){const i=r.prototype?.__cloneMongodbListener;i&&(i.forEach((r=>{n[e](t,l[r]),l[r]&&delete l[r]})),delete r.prototype.__cloneMongodbListener)}else n[e](t,e)}})),new Proxy({},{get:(e,t)=>a[t]?a[t]:"function"==typeof n[t]?n[t].bind(n):n[t],set(e,t,r){a[t]?a[t]=r:n[t]=r}})},a.aggregate=function(){const[e,n]=[...arguments],[a,s]=e,c=a?.$sample?.size,u=r(s?.$match),f=Number.isInteger(c)&&c>0&&t,h=i.aggregate(e.map((e=>e?.$match?{...e,$match:r(e.$match)}:e)),n),m=h.toArray.bind(h);h.toArray=async()=>o(await m());let y=async()=>{const[e,t]=await Promise.all(["asc","desc"].map((e=>i.find({...u}).sort(l,e).limit(1).toArray()))),[n,r]=[e[0]?.[l],t[0]?.[l]];if(isNaN(n)||isNaN(r))return[];if(n===r)return o(e);{const e=c+0,t=(r-n)/e,a=[];let s=n;Array(e).fill().forEach((()=>{a.push(p(s+=t,s))}));const f=await Promise.all(a.map((e=>i.find({...u,[`${l}`]:{$gte:e}}).sort(l,"asc").limit(3).toArray()))),h=d(f.flat().filter(((e,t,n)=>n.findIndex((t=>t._id===e._id))===t)));if(h.length>=c)return o(h.slice(0,c));{const e=await Promise.all(["asc","desc"].map((e=>i.find({...u}).sort(l,e).limit(Math.ceil(c/2)).toArray()))),t=[...h,...d(e.flat().filter(((e,t,n)=>n.findIndex((t=>t._id===e._id))===t)))].filter(((e,t,n)=>n.findIndex((t=>t._id===e._id))===t));return o(t.slice(0,c))}}};return new Proxy({},{get:(e,t)=>"toArray"===t&&f?y:"function"==typeof h[t]?h[t].bind(h):h[t],set(e,t,n){"toArray"===t&&f?y=n:h[t]=n}})}}}))})),new Proxy({},{get:(e,t)=>a[t]?a[t]:"function"==typeof i[t]?i[t].bind(i):i[t],set:(e,t,n)=>{a[t]?a[t]=n:i[t]=n}})};return new Proxy({},{get:(e,t)=>"collection"===t?i:"function"==typeof n[t]?n[t].bind(n):n[t],set(e,t,r){"collection"===t?i=r:n[t]=r}})},d=e=>{const t=[...e];let n,r=t.length;for(;0!=r;)n=Math.floor(Math.random()*r),r--,[t[r],t[n]]=[t[n],t[r]];return t},p=(e=70,t=0)=>(e-t)*Math.random()+t,h=e=>i.transformPunctuation(e.trim()),m=async(e,{fulltext:t,random:n,overhead:r})=>{if(r)return e;if(!y(e))return e;const i={...e};return t&&(t=Array.isArray(t)?t:[t],await Promise.all(t.map((async t=>{const n=e[t];"string"==typeof n&&n.trim()&&!e[`${s}${t}`]&&(i[`${s}${t}`]=await g(n))})))),n&&!e[l]&&(i[l]=Math.random()),i},y=e=>null!==e&&"object"==typeof e&&!Array.isArray(e),g=async e=>{if(!e?.trim?.())return[];const t=b(e),n=t.length>1?await Promise.all(t.map((e=>w(`${o}/worker.js`,{text:e})))):t.map((e=>({indexes:i.generateFulltextIndex(e)})));return[...new Set(n.map((e=>e.indexes)).flat())]},w=(e,n)=>new Promise((r=>{const i=new t.Worker(e);i.on("message",(e=>{r(e)})),i.postMessage(n)})),$=2e4,b=(e="")=>{e=e.split(" ");let t=[[]],n=0,r=0;for(let i=0;i<e.length;i++){const a=e[i];r+=a.length,++n<=2700&&r<$||!t[t.length-1].length?t[t.length-1].push(a):(t.push([a]),r=a.length,n=1)}const i=[];return t.forEach((e=>{e.length&&(e[0].length>$?Array(Math.ceil(e[0].length/$)).fill().forEach(((t,n)=>{i.push(e[0].substring(n*$,(n+1)*$))})):i.push(e.join(" ")))})),i};exports.FULLTEXT_ARRAY_PREFIX=s,exports.MongoClientHack=c,exports.RANDOMIZER_FIELD=l,exports.getFulltextArray=g,exports.overheadConfig=u,exports.proxyClient=e=>t=>{if(t.__intercepted)throw"this MongoClient instance was previously intercepted";u(t.db.bind(t),e);const n=t.db.bind(t);t.db=f(n,e),t.__intercepted=!0};
